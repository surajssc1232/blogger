<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Matrix Style Blogging</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet">
  <style>
    /* Set basic page style and matrix theme colors */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: black;
      font-family: 'Space Mono', monospace;
      color: #0f0;
    }
    /* Canvas for the matrix animation */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }
    /* Container for blog posts (positioned over the canvas) */
    #blog-container {
      position: absolute;
      top: calc(5px + env(safe-area-inset-top));
      left: calc(5px + env(safe-area-inset-left));
      right: calc(5px + env(safe-area-inset-right));
      bottom: calc(5px + env(safe-area-inset-bottom));
      overflow-y: auto;
      z-index: 1;
      pointer-events: none;
    }
    .blog-post {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.2); /* even more translucent glass-like background */
      border: 1px solid rgba(0, 255, 0, 0.4);
      border-radius: 10px;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 6px 15px rgba(0, 255, 0, 0.15);
      transition: transform 0.5s ease-out, opacity 0.5s ease-out;
    }
    .blog-post.selected {
      border: 2px solid red;
    }
    /* Compose modal for writing new blog posts */
    #compose-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border: 1px solid #0f0;
      display: none;
      z-index: 2;
    }
    #compose-modal textarea {
      width: 400px;
      height: 200px;
      background: black;
      color: #0f0;
      border: 1px solid #0f0;
      font-family: 'Space Mono', monospace;
      font-size: 16px;
      padding: 10px;
      resize: none;
    }
    /* Instruction overlay at the bottom */
    #instructions {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border: 1px solid #0f0;
      font-size: 14px;
      z-index: 3;
    }
    /* Removed mobile button styles:
       #new-post-button and #compose-buttons are no longer used.
    */
    /* 
    #new-post-button {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #0f0;
      color: #0f0;
      font-size: 16px;
      padding: 10px 15px;
      border-radius: 5px;
      z-index: 4;
      cursor: pointer;
    }
    #compose-buttons {
      display: none;
    }
    */
    /* Removed media queries for mobile buttons */
    /*
    @media (max-width: 600px) {
      #new-post-button {
        display: block;
      }
      #instructions {
        display: none;
      }
      #compose-buttons {
        display: block;
        margin-top: 10px;
        text-align: center;
      }
      #compose-buttons button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #0f0;
        color: #0f0;
        font-size: 16px;
        padding: 5px 10px;
        margin: 0 5px;
        cursor: pointer;
      }
    }
    */
    /* Added vanish animation for mobile instruction messages/hints */
    #instructions.vanish {
      animation: vanish-out 1s forwards;
    }
    @keyframes vanish-out {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
    /* Added fade-in effect for new blog posts */
    .new-post {
      opacity: 0;
      animation: fadeIn 1s forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Fullscreen overlay for mobile devices */
    #fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 9999;
    }

    /* Typewriter animation for the fullscreen message */
    #fullscreen-message {
      color: #0f0;
      font-size: 24px;
      font-family: 'Space Mono', monospace;
      overflow: hidden;              /* Hide the overflow */
      white-space: nowrap;           /* Keep text in a single line */
      border-right: 0.15em solid #0f0;/* The blinking caret */
      width: 0;                      /* Start with zero width */
      animation: typing 3s steps(30, end) forwards, blink-caret 0.75s step-end infinite;
    }

    /* Keyframes for typewriter effect */
    @keyframes typing {
      from { width: 0; }
      to { width: 100%; }
    }

    @keyframes blink-caret {
      from, to { border-color: transparent; }
      50% { border-color: #0f0; }
    }

    @media (max-width: 600px) {
      /* Modern mobile formatting */
      #compose-modal {
        width: 90%;
        max-width: 400px;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 255, 0, 0.2);
        box-sizing: border-box;
      }
      
      #compose-modal textarea {
        width: 100%;
        height: 150px;
        font-size: 16px;
        box-sizing: border-box;
      }
      
      #instructions {
        font-size: 16px;
        padding: 8px 12px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.7);
      }
      
      #blog-container {
        top: calc(5px + env(safe-area-inset-top));
        left: calc(5px + env(safe-area-inset-left));
        right: calc(5px + env(safe-area-inset-right));
        bottom: calc(5px + env(safe-area-inset-bottom));
      }
      
      .blog-post {
        margin-bottom: 15px;
        padding: 8px;
        border-radius: 8px;
      }
    }

    /* Slide out animation for blog deletion */
    .slide-out-left {
      transform: translateX(-100%);
      opacity: 0;
    }
  </style>
</head>
<body>
  <!-- Matrix background canvas -->
  <canvas id="matrixCanvas"></canvas>

  <!-- Container for blog posts -->
  <div id="blog-container"></div>
  
  <!-- Compose modal for new blog post (removed mobile buttons below) -->
  <div id="compose-modal">
    <textarea id="compose-text" placeholder="Write your blog post here..."></textarea>
    <!-- Updated prompt for mobile (will be overwritten by JS on mobile) -->
    <p style="color:#0f0;">Press Ctrl+Enter to post, Esc to cancel.</p>
    <!-- Removed mobile compose buttons
    <div id="compose-buttons">
      <button id="post-button">Post</button>
      <button id="cancel-button">Cancel</button>
    </div>
    -->
  </div>
  
  <!-- Instruction overlay -->
  <div id="instructions">Press 'N' for new blog post</div>
  <!-- Fullscreen overlay for mobile devices -->
  <div id="fullscreen-overlay">
    <div id="fullscreen-message">Tap anywhere to enter fullscreen</div>
  </div>
  
  <!-- Removed mobile new post button
  <button id="new-post-button">New Post</button>
  -->
  
  <script>
    // Matrix background animation
    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const fontSize = 16;
    ctx.font = fontSize + 'px "Space Mono", monospace';
    const columns = Math.floor(canvas.width / fontSize);
    const drops = [];
    for (let i = 0; i < columns; i++) {
      drops[i] = Math.random() * canvas.height;
    }

    function drawMatrix() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#0F0';

      for (let i = 0; i < drops.length; i++) {
        const text = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96));
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i] += 0.5;
      }
      requestAnimationFrame(drawMatrix);
    }
    drawMatrix();

    // Blog functionality
    const blogContainer = document.getElementById('blog-container');
    const composeModal = document.getElementById('compose-modal');
    const composeText = document.getElementById('compose-text');

    // NEW: Add persistence using localStorage
    let blogPosts = [];
    const STORAGE_KEY = 'matrix_blog_posts';

    function saveBlogPosts() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(blogPosts));
    }

    function createBlogPostElement(postData) {
      const post = document.createElement('div');
      post.classList.add('blog-post', 'new-post');
      post.dataset.id = postData.id;
      post.innerHTML = '<strong>' + postData.time + '</strong><br>' + postData.content.replace(/\n/g, '<br>');
      // Add click event so user can select the post with a mouse click
      post.addEventListener('click', function(e) {
        e.stopPropagation();
        selectPost(post);
      });
      // Remove the fade-in class after the animation completes
      post.addEventListener('animationend', function() {
        post.classList.remove('new-post');
      });
      // Add swipe-left detection for mobile devices to delete a blog post
      if (window.innerWidth < 600) {
        let touchStartX = 0;
        post.addEventListener('touchstart', function(e) {
          touchStartX = e.changedTouches[0].clientX;
        });
        post.addEventListener('touchend', function(e) {
          let touchEndX = e.changedTouches[0].clientX;
          if (touchStartX - touchEndX > 50) {  // if swiped left more than 50px
            // Add slide-out animation then delete the blog post after the transition ends
            post.classList.add('slide-out-left');
            post.addEventListener('transitionend', function() {
              const nextSelection = post.nextElementSibling || post.previousElementSibling;
              const idToDelete = post.dataset.id;
              blogPosts = blogPosts.filter(p => p.id != idToDelete);
              saveBlogPosts();
              if (selectedPost === post) {
                selectPost(nextSelection);
              }
              if (post.parentElement) {
                post.parentElement.removeChild(post);
              }
            }, { once: true });
          }
        });
      }
      return post;
    }

    function loadBlogPosts() {
      const savedPosts = localStorage.getItem(STORAGE_KEY);
      if (savedPosts) {
        blogPosts = JSON.parse(savedPosts);
        // Render posts so that newest posts are on top
        blogPosts.forEach(postData => {
          const postElement = createBlogPostElement(postData);
          blogContainer.prepend(postElement);
        });
      }
    }

    // Global variables for selection and edit mode
    let selectedPost = null;
    let editMode = false;
    let editTarget = null;

    // Helper to update selected post
    function selectPost(post) {
      if (selectedPost) {
        selectedPost.classList.remove('selected');
      }
      selectedPost = post;
      if (selectedPost) {
        selectedPost.classList.add('selected');
        // Scroll the selected post into view smoothly
        selectedPost.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // Open compose modal (clears previous text)
    function openComposeModal() {
      composeText.value = '';
      composeModal.style.display = 'block';
      composeText.focus();
      // If on mobile, reset and then vanish the modal prompt after 2 seconds
      if (window.innerWidth < 600) {
        const modalPrompt = composeModal.querySelector('p');
        modalPrompt.classList.remove('vanish'); // reset any vanish styling
        modalPrompt.style.opacity = 1;           // ensure it is fully visible
        setTimeout(() => {
          modalPrompt.classList.add('vanish');
        }, 2000);
      }
    }

    // Close compose modal
    function closeComposeModal() {
      composeModal.style.display = 'none';
      editMode = false;
      editTarget = null;
    }

    // UPDATED: Add a new blog post with a timestamp and update persistent storage
    function addBlogPost(text) {
      const id = Date.now(); // Generate a unique id
      const time = new Date().toLocaleTimeString();
      const postData = { id, time, content: text };
      blogPosts.push(postData);
      const post = createBlogPostElement(postData);
      blogContainer.prepend(post);
      saveBlogPosts();
    }

    // Global keydown listener for creating and posting blogs
    document.addEventListener('keydown', function(e) {
      if (composeModal.style.display === 'block') {
        if (e.key === 'Escape') {
          closeComposeModal();
        } else if ((e.key === 'Enter' || e.key === 'Return') && e.ctrlKey) {
          const text = composeText.value.trim();
          if (text) {
            if (editMode && editTarget) {
              // Update the existing post with a new timestamp and update localStorage
              const id = editTarget.dataset.id;
              const time = new Date().toLocaleTimeString();
              editTarget.innerHTML = '<strong>' + time + '</strong><br>' + text.replace(/\n/g, '<br>');
              const post = blogPosts.find(post => post.id == id);
              if (post) {
                post.time = time;
                post.content = text;
              }
            } else {
              addBlogPost(text);
            }
          }
          closeComposeModal();
          editMode = false;
          editTarget = null;
          saveBlogPosts();
        }
      } else {
        if (e.key.toLowerCase() === 'n') {
          // Open compose modal for a new blog post
          editMode = false;
          editTarget = null;
          openComposeModal();
        } else if (e.key === 'ArrowDown') {
          // Select the next blog post
          if (selectedPost && selectedPost.nextElementSibling) {
            selectPost(selectedPost.nextElementSibling);
          } else if (!selectedPost && blogContainer.firstElementChild) {
            selectPost(blogContainer.firstElementChild);
          }
        } else if (e.key === 'ArrowUp') {
          // Select the previous blog post
          if (selectedPost && selectedPost.previousElementSibling) {
            selectPost(selectedPost.previousElementSibling);
          } else if (!selectedPost && blogContainer.lastElementChild) {
            selectPost(blogContainer.lastElementChild);
          }
        } else if (e.key === 'Delete' || (e.ctrlKey && e.key.toLowerCase() === 'd')) {
          e.preventDefault();
          // Delete the selected blog post and update persistent storage
          if (selectedPost) {
            const nextSelection = selectedPost.nextElementSibling || selectedPost.previousElementSibling;
            const idToDelete = selectedPost.dataset.id;
            blogPosts = blogPosts.filter(post => post.id != idToDelete);
            selectedPost.parentElement.removeChild(selectedPost);
            saveBlogPosts();
            selectPost(nextSelection);
          }
        } else if (e.key.toLowerCase() === 'e') {
          // Edit the selected blog post
          if (selectedPost) {
            editMode = true;
            editTarget = selectedPost;
            let htmlContent = selectedPost.innerHTML;
            const idx = htmlContent.indexOf('<br>');
            let content = "";
            if (idx !== -1) {
              content = htmlContent.substring(idx + 4);
              // Replace <br> tags with newline characters
              content = content.replace(/<br>/g, "\n");
            }
            composeText.value = content;
            composeModal.style.display = 'block';
            composeText.focus();
          }
        }
      }
    });

    // REMOVED: Mobile button event listeners
    /*
    // Mobile: Add event listener to New Post button
    const newPostButton = document.getElementById('new-post-button');
    newPostButton.addEventListener('click', function() {
      editMode = false;
      editTarget = null;
      openComposeModal();
    });

    // Mobile: Post and Cancel buttons in compose modal
    const postButton = document.getElementById('post-button');
    const cancelButton = document.getElementById('cancel-button');

    postButton.addEventListener('click', function(e) {
      const text = composeText.value.trim();
      if (text) {
        if (editMode && editTarget) {
          const id = editTarget.dataset.id;
          const time = new Date().toLocaleTimeString();
          editTarget.innerHTML = '<strong>' + time + '</strong><br>' + text.replace(/\n/g, '<br>');
          const post = blogPosts.find(post => post.id == id);
          if (post) {
            post.time = time;
            post.content = text;
          }
        } else {
          addBlogPost(text);
        }
      }
      closeComposeModal();
      editMode = false;
      editTarget = null;
      saveBlogPosts();
    });

    cancelButton.addEventListener('click', function(e) {
      closeComposeModal();
    });
    */

    // Load persisted blog posts on page load
    loadBlogPosts();

    // DOUBLE TAP DETECTION for MOBILE DEVICES
    if (window.innerWidth < 600) {
      // Update instructions and modal prompt for mobile
      document.getElementById('instructions').textContent = 'Double tap to compose/post a blog';
      const modalPrompt = composeModal.querySelector('p');
      modalPrompt.textContent = 'Double tap to post, Esc to cancel';
      
      // Vanish the instructions overlay after 2 seconds
      setTimeout(() => {
        document.getElementById('instructions').classList.add('vanish');
      }, 2000);
      // Also vanish the modal prompt (if initially visible) after 2 seconds
      setTimeout(() => {
        modalPrompt.classList.add('vanish');
      }, 2000);
      
      let tapCount = 0;
      let tapTimer = null;
      document.addEventListener('touchend', function(e) {
        tapCount++;
        if (tapTimer) {
          clearTimeout(tapTimer);
        }
        tapTimer = setTimeout(() => {
          if (tapCount === 2) {
            // Double tap detected: compose or post a blog
            if (composeModal.style.display === 'block') {
              const text = composeText.value.trim();
              if (text) {
                if (editMode && editTarget) {
                  const id = editTarget.dataset.id;
                  const time = new Date().toLocaleTimeString();
                  editTarget.innerHTML = '<strong>' + time + '</strong><br>' + text.replace(/\n/g, '<br>');
                  const post = blogPosts.find(post => post.id == id);
                  if (post) {
                    post.time = time;
                    post.content = text;
                  }
                } else {
                  addBlogPost(text);
                }
              }
              closeComposeModal();
              editMode = false;
              editTarget = null;
              saveBlogPosts();
            } else {
              // If modal is not open, open compose modal for a new post
              editMode = false;
              editTarget = null;
              openComposeModal();
            }
          }
          tapCount = 0;
          tapTimer = null;
        }, 300);
      });
    }

    // Fullscreen overlay behavior for mobile devices
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    if (window.innerWidth < 600) {
      fullscreenOverlay.style.display = 'flex';
      fullscreenOverlay.addEventListener('click', function() {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
          document.documentElement.msRequestFullscreen();
        }
        fullscreenOverlay.style.display = 'none';
      });
    } else {
      fullscreenOverlay.style.display = 'none';
    }
  </script>
</body>
</html>
